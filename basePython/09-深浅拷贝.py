# 深浅拷贝
'''
1. 浅拷贝：浅拷贝只会把原内容第一层的索引和内存地址一摸一样拷贝到一个新的内存里。原内容里不可变类型（字符串）
         在新内存变量内容改变时，会形成新的内存空间存放变值；原内容里的可变类型（列表）的子列表内存地址不会改变
         总：会把原列表第一层存的索引和内存地址完全拷贝一份给新列表，如果原列表存放的是不可表类型，浅拷贝可以独立更改
             若包含可变类型，浅拷贝的原列表就和新列表无法分开了。
2. 深拷贝：针对可变类型，新开辟空间，更改值时，新开辟空间。两者内容完全独立。
3. 总：列表内只有不可变类型，浅拷贝copy可以应付；列表内有可变类型，需要import copy;copy.deepcopy(a)完全应对。
      深拷贝额外引用模块，影响效率
'''
# 1 浅拷贝
l1 =['刘少博','冯攀峰',['1','2']] # 栈区存放变量名；堆区存放变量名的内存地址和实值的内存地址
l2 = l1 # 把l1的内存地址给了l2。二者同时指向一个内存地址
l1[0] = 'lsb' # 指向同一内存地址，一个改动，另一个也会改动。两者无法分割开
print(l1)
print(l2)

# 1 浅拷贝
l3 = l1.copy()
print(id(l1),id(l3)) # id不一样！又新开辟了一个内存地址
print(id(l1[0]),id(l1[1]),id(l1[2]))
print(id(l3[0]),id(l3[1]),id(l3[2])) # 里面所有内容id一样！
# ！！！copy()只是新开辟了一个内存空间，里面装的内容仍跟l1内容一样

# 不可变类型内容改变；可变类型内容不改变
l3[0],l3[1] = 'lsb111','fpf000'
l3[2][0],l3[2][1] = '3','4'
print(l1,l3)

# 2 深拷贝
import copy
l4 = copy.deepcopy(l1)
print(l1,l4)
print(id(l1),id(l4)) # id不一致，新开辟空间
print(id(l1[0]),id(l1[1]),id(l1[2]))
print(id(l4[0]),id(l4[1]),id(l4[2])) # 不可变类型id一样，可变类型id不同（新开辟内存）

l4[0],l4[1] = 'lsb111','fpf000'
l4[2][0],l4[2][1] = '5','6' 
print(l1,l4) # 可变类型里面内存不一致