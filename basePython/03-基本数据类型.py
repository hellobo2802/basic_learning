# 基本数据类型
'''
1. 整型int、浮点型float。二者相加为浮点型，也可以比较
2. 字符串，使用' '、""" """引用起来
3. 字符串中有引号的话，可以单双引号穿插，也可以使用转义字符\。转义字符 \直接加符号，e.g. \'
4. 字符串相加：字符串之间；字符串相乘：字符串可以和数字n相乘，表示该字符串重复n次
5. 列表：记录多个值，可以按照索引取值，使用'[]'和','存储。列表里面可以嵌套各种数据类型，比如列表
6. 列表一般存同一种属性，如员工姓名、员工工资。索引从后往前为-1开始
7. 字典类型格式{'key':value,}key要加''!
8. 字典和列表可以相互嵌套。列表下可以有列表、字典...，字典下可以有字典、列表...
9. NoneType数据类型的唯一值：None。有值的变量为True，而0，None，空列表[]，空字典{}为False
10. 变量引用有直接引用和间接引用两种方式。针对容器类型的变量引用为什么叫间接引用呢？内存中存放索引或key，同时存放对应值的内存地址！根据地址找到真正的存储值
11. 循环引用导致内存泄漏，可以使用【标记清除】方式解决。标记清除：内存中的栈区存放变量名，堆区存放内存地址，直接引用时二者建立联系，del 变量名之后，堆中的内存
    地址没有被移除，相应的栈中的变量名就不会被销毁，造成内存泄露。当程序内存空间不够用时，暂停程序，扫描栈区，将可以通过栈区变量名可以引用（直接+间接）到的内存地址
    标记为存活状态，栈区和堆区引用不到的值标记为死亡状态，死亡状态的值会直接被清理，即使引用计数不为0
12. 垃圾回收效率低下解决方案：分代回收。起始扫描全部，标记良好，三次全部良好的变量减少扫描频率，增大扫描周期，后续扫描中再出现良好的变量，加入良好中；良好中的变量权重
    再次达到设定值，标记为优秀，再次减少扫描频率，增大扫描周期
    【总结】_垃圾回收机制_主要用_引用计数_来扫描并回收垃圾，用_标记清除_解决引用计数回收不了的垃圾，用_分代回收_解决引用计数扫描的效率问题
'''

# 1 
age = 2
print(type(age))
number = 3.5
print(number, type(number))
print(age > number)
print(age + number , type(age + number)) # 结果为浮点型
print(age * 2)

# 2 字符串用于记录描述
quotes = '好好学习，习惯延迟满足'
print(quotes,type(quotes))

a = 18
b = '18'
print(type(a),type(b))

# 3 字符串中有引号的话，可以单双引号穿插，也可以使用转义字符\
name1 = '我叫"刘少博"'
name2 = '我叫\'刘少博\''
name3 = '我叫\\刘少博\\'
print(name1,name2,name3)

# 4 字符串之间直接相加，效率低，不推荐。字符串重复n次使用字符串与数字相乘

print('-' * 100)

talk = 'I like '
you= '冯攀峰'
print(talk + you)

print(talk + you * 5) # 四则运算顺序

print('-' * 100)

# 5 索引和C语言一样，下标从0开始
print('-' * 100)
# 索引  0  1     2      3
lie = [10,3.5,'我们',[1,2,3,'123']]
print(lie[0],lie[1],lie[2],lie[3])
print(lie[3][3]) # 列表的嵌套取值
print('-' * 100)

# 6 索引-1表示最后一个
name = ['刘少博','冯攀峰']
print(name[0])
print(name[-1])
# 列表嵌套
person = [
    ['刘少博',22,'学习','喜欢冯攀峰',['1',2,3]],
    ['冯攀峰',18,'读书','喜欢刘少博',['4',5,6]],
    ['李白',66,'写诗','喜欢喝酒',['7',8,9]]
]
print('-' * 100)
print(person[0][0] + person[0][3])
print(person[1][0] +  person[1][3])
print(person[0][0] + person[0][3] + person[0][4][0]) # 取到最里面的字符串'1'
print((person[1][0] + person[1][3]) * person[1][4][1]) # 渠道最里面数字5，并使字符串重复5遍
print('-' * 100)

# 7 列表类型存放大量数据时，索引繁琐，内容不直观，使用字典
dic = {
    'name':'刘少博',
    'age':12,
    'height':188
    }
print('-' * 100)
print(type(dic))
print('-' * 100)

print(dic['name']) # 字典取值按照['key']取值。字典和列表可以相互嵌套

# 布尔类型bool
a = True # 1
b = False # 0
print('-' * 100)
print(type(a))
print('-' * 100)

# 9 特殊常量None
c = None # 表示空值
print(type(c)) # 数据类型为NoneType!

# 10 间接引用就是使用已定义好的变量，间接引用一般用在容器类型列表、字典中
initiative = '主动性，积极性'
initiativeList = [1,'汉语意思',initiative]
print(id(initiative))
print(id(initiativeList[2]))  # id一样，其中该字符串不在小整数池中，内存地址'主动性，积极性'的引用计数为2

name = '刘少博'
List = ['123',123,name]
name = '冯攀峰'
print('-' * 100)
print(List[2]) # name更新了吗？在 name = '冯攀峰' 语句中，name与'刘少博'内存地址断开，但原列表索引2指向的'刘少博'内存地址不变  
print(name)
print('-' * 100)

 # 11 l1,l2循环引用，引用计数不为0（有间接引用），但是无任何办法直接访问到原始['a','b']、['x','y']，这两个垃圾不能被回收！
l1 = ['a','b']
l2 = ['x','y']
l1.append(l2)
print(l1) # l1 = ['a','b',['x','y']] 注意直接把l2放在l1中，不是取其元素！！！
print(id(l2), id(l1[2]))
l2.append(l1) # 循环引用
print(l2) # ['x', 'y', ['a', 'b', [...]]]
del l1 # 不是删除变量，而是断开直接引用，使其引用计数-1
del l2 # 不是删除变量，而是断开直接引用，使其引用计数-1

# 内存中的栈区存放变量名，堆区存放内存地址，直接引用时二者建立联系